const express = require('express');
const router = express.Router();
const XLSX = require('xlsx');
const path = require('path');
const pool = require('../db');
const cloneTableStructure = require('../clone_table_structure');
const moment = require('moment');
const multer = require('multer');
const fs = require('fs');

// Configuration de multer pour l'upload de fichiers
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadDir = path.join(__dirname, '../../Reports_Moodies');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    // Utiliser l'id comme nom de fichier
    const fileName = `${req.params.id}_${Date.now()}${path.extname(file.originalname)}`;
    cb(null, fileName);
  }
});

const upload = multer({
  storage: storage,
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'application/pdf') {
      cb(null, true);
    } else {
      cb(new Error('Seuls les fichiers PDF sont acceptés'));
    }
  },
  limits: {
    fileSize: 10 * 1024 * 1024 // Limite à 10MB
  }
});


// Fonction pour créer une table dynamiquement basée sur les colonnes du fichier Excel
async function createDynamicTableFromExcel(client, tableName, excelData) {
  console.log('Création d\'une table dynamique basée sur les colonnes du fichier Excel');
  
  if (!excelData || excelData.length === 0) {
    throw new Error('Aucune donnée Excel fournie pour créer la table');
  }
  
  // Récupérer toutes les colonnes uniques de toutes les lignes
  const allColumns = new Set();
  excelData.forEach(row => {
    Object.keys(row).forEach(col => allColumns.add(col));
  });
  
  console.log(`Colonnes trouvées dans le fichier Excel: ${Array.from(allColumns).join(', ')}`);
  
  // Convertir les noms de colonnes Excel en noms de colonnes PostgreSQL valides
  const dbColumns = Array.from(allColumns).map(excelCol => {
    // Convertir en snake_case pour PostgreSQL
    let dbCol = excelCol.toLowerCase()
      .replace(/[^a-z0-9]+/g, '_')  // Remplacer les caractères non alphanumériques par des underscores
      .replace(/^_|_$/g, '')        // Supprimer les underscores au début et à la fin
      .replace(/__+/g, '_');        // Remplacer les underscores multiples par un seul
    
    // Cas spécial pour "Evaluated / Not Evaluated"
    if (excelCol === 'Evaluated / Not Evaluated') {
      dbCol = 'evaluated_not_evaluated';
    }
    
    // Éviter les noms de colonnes qui sont des mots-clés SQL
    const sqlKeywords = ['order', 'group', 'table', 'select', 'where', 'from', 'join', 'having', 'limit'];
    if (sqlKeywords.includes(dbCol)) {
      dbCol = `excel_${dbCol}`;
    }
    
    return { excelCol, dbCol };
  });
  
  // Créer un mapping pour une utilisation ultérieure
  const columnMapping = {};
  dbColumns.forEach(({ excelCol, dbCol }) => {
    columnMapping[excelCol] = dbCol;
  });
  
  // Déterminer les types de données pour chaque colonne
  const columnTypes = {};
  
  // Analyser les données pour déterminer les types
  excelData.forEach(row => {
    dbColumns.forEach(({ excelCol, dbCol }) => {
      const value = row[excelCol];
      
      // Ignorer les valeurs null/undefined pour la détermination du type
      if (value === null || value === undefined) return;
      
      // Déterminer le type de données
      if (typeof value === 'number') {
        // Vérifier si c'est un entier ou un nombre à virgule flottante
        if (Number.isInteger(value)) {
          columnTypes[dbCol] = 'INTEGER';
        } else {
          columnTypes[dbCol] = 'NUMERIC';
        }
      } else if (typeof value === 'boolean') {
        columnTypes[dbCol] = 'BOOLEAN';
      } else if (value instanceof Date) {
        columnTypes[dbCol] = 'DATE';
      } else if (typeof value === 'string') {
        // Vérifier si c'est une date
        if (/^\d{2}[\/-]\d{2}[\/-]\d{4}$/.test(value) || 
            /^\d{4}[\/-]\d{2}[\/-]\d{2}$/.test(value)) {
          columnTypes[dbCol] = 'DATE';
        } else {
          // Utiliser TEXT pour les chaînes de caractères
          columnTypes[dbCol] = columnTypes[dbCol] || 'TEXT';
        }
      } else {
        // Type par défaut
        columnTypes[dbCol] = 'TEXT';
      }
    });
  });
  
  // Définir des types spécifiques pour certaines colonnes basées sur leur nom
  dbColumns.forEach(({ dbCol }) => {
    // Colonnes d'ID
    if (dbCol === 'id' || dbCol.endsWith('_id') || dbCol.startsWith('id_')) {
      columnTypes[dbCol] = 'TEXT';
    }
    
    // Colonnes de date
    if (dbCol.includes('date') || dbCol.includes('time')) {
      columnTypes[dbCol] = 'TEXT';
    }
    
    // Colonnes monétaires
    if (dbCol.includes('price') || dbCol.includes('cost') || dbCol.includes('amount') || 
        dbCol.includes('spend') || dbCol.includes('value')) {
      columnTypes[dbCol] = 'NUMERIC';
    }
    
    // Colonnes de score
    if (dbCol === 'score' || dbCol.includes('rating') || dbCol.includes('rank')) {
      columnTypes[dbCol] = 'INTEGER';
    }
  });
  
  // Toujours avoir une colonne id comme clé primaire
  if (!columnTypes['id']) {
    columnTypes['id'] = 'SERIAL PRIMARY KEY';
  } else {
    // Si id existe déjà, s'assurer qu'il est une clé primaire
    columnTypes['id'] = 'TEXT PRIMARY KEY';
  }
  
  // Construire la requête SQL pour créer la table
  let createTableSQL = `CREATE TABLE "${tableName}" (
`;
  
  // Ajouter chaque colonne avec son type
  const columnDefinitions = Object.entries(columnTypes).map(([col, type]) => {
    return `  "${col}" ${type}`;
  });
  
  createTableSQL += columnDefinitions.join(',\n');
  createTableSQL += '\n)';
  
  console.log('Requête SQL pour créer la table:');
  console.log(createTableSQL);
  
  // Exécuter la requête SQL
  await client.query(createTableSQL);
  console.log(`Table ${tableName} créée avec succès`);
  
  return { columnMapping, columnTypes };
}



// Fonction pour normaliser les noms de colonnes PostgreSQL tout en préservant les accents
function normalizeColumnName(name) {
  // Remplacer les caractères non alphanumériques (sauf les accents) par des underscores
  return name.replace(/[^a-zA-Z0-9àáâäãåąčćęèéêëėįìíîïłńòóôöõøùúûüųūÿýżźñçšžÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆŠŽ]+/g, '_')
    .replace(/^_|_$/g, '')        // Supprimer les underscores au début et à la fin
    .replace(/__+/g, '_');        // Remplacer les underscores multiples par un seul
}

// Fonction pour créer une table dynamiquement basée sur les colonnes du fichier Excel
async function createDynamicTableFromExcel(client, tableName, excelData) {
  console.log('Création d\'une table dynamique basée sur les colonnes du fichier Excel');
  
  if (!excelData || excelData.length === 0) {
    throw new Error('Aucune donnée Excel fournie pour créer la table');
  }
  
  // Récupérer toutes les colonnes uniques de toutes les lignes
  const allColumns = new Set();
  excelData.forEach(row => {
    Object.keys(row).forEach(col => allColumns.add(col));
  });
  
  console.log(`Colonnes trouvées dans le fichier Excel (${allColumns.size}): ${Array.from(allColumns).join(', ')}`);
  
  // Convertir les noms de colonnes Excel en noms de colonnes PostgreSQL valides
  const dbColumns = Array.from(allColumns).map(excelCol => {
    // Cas spécial pour "Evaluated / Not Evaluated"
    if (excelCol === 'Evaluated / Not Evaluated') {
      return { excelCol, dbCol: 'evaluated_not_evaluated' };
    }
    
    // Normaliser le nom de colonne en préservant les accents
    let dbCol = normalizeColumnName(excelCol.toLowerCase());
    
    // Éviter les noms de colonnes qui sont des mots-clés SQL
    const sqlKeywords = ['order', 'group', 'table', 'select', 'where', 'from', 'join', 'having', 'limit'];
    if (sqlKeywords.includes(dbCol)) {
      dbCol = `excel_${dbCol}`;
    }
    
    return { excelCol, dbCol };
  });
  
  // Créer un mapping pour une utilisation ultérieure
  const columnMapping = {};
  dbColumns.forEach(({ excelCol, dbCol }) => {
    columnMapping[excelCol] = dbCol;
  });
  
  // Déterminer les types de données pour chaque colonne
  const columnTypes = {};
  
  // Analyser les données pour déterminer les types
  excelData.forEach(row => {
    dbColumns.forEach(({ excelCol, dbCol }) => {
      const value = row[excelCol];
      
      // Ignorer les valeurs null/undefined pour la détermination du type
      if (value === null || value === undefined) return;
      
      // Déterminer le type de données
      if (typeof value === 'number') {
        // Vérifier si c'est un entier ou un nombre à virgule flottante
        if (Number.isInteger(value)) {
          columnTypes[dbCol] = 'INTEGER';
        } else {
          columnTypes[dbCol] = 'NUMERIC';
        }
      } else if (typeof value === 'boolean') {
        columnTypes[dbCol] = 'BOOLEAN';
      } else if (value instanceof Date) {
        columnTypes[dbCol] = 'DATE';
      } else if (typeof value === 'string') {
        // Vérifier si c'est une date
        if (/^\d{2}[\/-]\d{2}[\/-]\d{4}$/.test(value) || 
            /^\d{4}[\/-]\d{2}[\/-]\d{2}$/.test(value)) {
          columnTypes[dbCol] = 'DATE';
        } else {
          // Utiliser TEXT pour les chaînes de caractères
          columnTypes[dbCol] = columnTypes[dbCol] || 'TEXT';
        }
      } else {
        // Type par défaut
        columnTypes[dbCol] = 'TEXT';
      }
    });
  });
  
  // Définir des types spécifiques pour certaines colonnes basées sur leur nom
  dbColumns.forEach(({ dbCol }) => {
    // Colonnes d'ID
    if (dbCol === 'id' || dbCol.endsWith('_id') || dbCol.startsWith('id_')) {
      columnTypes[dbCol] = 'TEXT';
    }
    
    // Colonnes de date
    if (dbCol.includes('date') || dbCol.includes('time')) {
      columnTypes[dbCol] = 'TEXT';
    }
    
    // Colonnes monétaires
    if (dbCol.includes('price') || dbCol.includes('cost') || dbCol.includes('amount') || 
        dbCol.includes('spend') || dbCol.includes('value')) {
      columnTypes[dbCol] = 'NUMERIC';
    }
    
    // Colonnes de score
    if (dbCol === 'score' || dbCol.includes('rating') || dbCol.includes('rank')) {
      columnTypes[dbCol] = 'INTEGER';
    }
  });
  
  // Toujours avoir une colonne id comme clé primaire
  if (!columnTypes['id']) {
    columnTypes['id'] = 'SERIAL PRIMARY KEY';
  } else {
    // Si id existe déjà, s'assurer qu'il est une clé primaire
    columnTypes['id'] = 'TEXT PRIMARY KEY';
  }
  
  // Construire la requête SQL pour créer la table
  let createTableSQL = `CREATE TABLE "${tableName}" (
`;
  
  // Ajouter chaque colonne avec son type
  const columnDefinitions = Object.entries(columnTypes).map(([col, type]) => {
    return `  "${col}" ${type}`;
  });
  
  createTableSQL += columnDefinitions.join(',\n');
  createTableSQL += '\n)';
  
  console.log('Requête SQL pour créer la table:');
  console.log(createTableSQL);
  
  // Exécuter la requête SQL
  await client.query(createTableSQL);
  console.log(`Table ${tableName} créée avec succès`);
  
  return { columnMapping, columnTypes };
}


// Fonction pour convertir une date en format MM/DD/YYYY
function convertToUSFormat(dateString) {
  if (!dateString) return null;
  console.log(`Tentative de conversion de la date: "${dateString}"`);

  // Nettoyer la chaîne de caractères
  dateString = dateString.trim();

  // Format court (D/M/YY, DD/M/YY, D/MM/YY ou DD/MM/YY)
  const shortDateRegex = /^(\d{1,2})\/(\d{1,2})\/(\d{2})$/;
  if (shortDateRegex.test(dateString)) {
    const [full, d, m, y] = dateString.match(shortDateRegex);
    const day = parseInt(d, 10);
    const month = parseInt(m, 10);
    const year = parseInt(y, 10);
    
    // Validation des valeurs
    if (day < 1 || day > 31 || month < 1 || month > 12) {
      console.warn(`Valeurs de date invalides - Jour: ${day}, Mois: ${month}, Année: ${year}`);
      return null;
    }

    // Déterminer le format (EU vs US) basé sur les valeurs
    let finalDay, finalMonth;
    if (month > 12) {
      // Si le "mois" est > 12, c'est probablement le jour en format EU
      finalDay = month;
      finalMonth = day;
    } else {
      // Format EU par défaut (DD/MM/YY)
      finalDay = day;
      finalMonth = month;
    }

    const fullYear = year < 50 ? 2000 + year : 1900 + year;
    const result = `${finalMonth.toString().padStart(2, '0')}/${finalDay.toString().padStart(2, '0')}/${fullYear}`;
    console.log(`Date courte convertie: ${dateString} -> ${result}`);
    return result;
  }

  // Si c'est déjà au format MM/DD/YYYY
  const fullDateRegex = /^(0[1-9]|1[0-2])\/(0[1-9]|[12]\d|3[01])\/\d{4}$/;
  if (fullDateRegex.test(dateString)) {
    console.log(`Date déjà au format US: ${dateString}`);
    return dateString;
  }

  // Essayer différents formats de date avec moment
  const formats = [
    'DD/MM/YYYY',
    'D/M/YYYY',
    'DD/M/YYYY',
    'D/MM/YYYY',
    'YYYY-MM-DD',
    'DD-MM-YYYY',
    'DD.MM.YYYY',
    'YYYY/MM/DD'
  ];

  for (const format of formats) {
    const momentDate = moment(dateString, format, true);
    if (momentDate.isValid()) {
      const result = momentDate.format('MM/DD/YYYY');
      console.log(`Format moment trouvé: ${format} -> ${result}`);
      return result;
    }
  }

  console.warn(`Aucun format ne correspond à la date: ${dateString}`);
  return null;
}

// Fonction pour convertir une date au format PostgreSQL (YYYY-MM-DD)
function convertToPostgresDate(dateString) {
  if (!dateString) return null;
  console.log(`\nConversion en format PostgreSQL pour: "${dateString}"`);

  // D'abord convertir en format US
  const usDate = convertToUSFormat(dateString);
  if (!usDate) {
    console.warn(`Échec de la conversion en format US pour: ${dateString}`);
    return null;
  }

  try {
    // Convertir en format PostgreSQL
    const momentDate = moment(usDate, 'MM/DD/YYYY', true);
    if (!momentDate.isValid()) {
      console.warn(`Date US invalide: ${usDate}`);
      return null;
    }
    const result = momentDate.format('YYYY-MM-DD');
    console.log(`Date convertie en format PostgreSQL: ${result}`);
    return result;
  } catch (error) {
    console.error(`Erreur lors de la conversion en PostgreSQL: ${error.message}`);
    return null;
  }
}

// Fonction pour convertir un numéro de série Excel en date
function excelSerialDateToJSDate(serial) {
  if (!serial) return null;
  
  const utc_days  = Math.floor(serial - 25569);
  const utc_value = utc_days * 86400;
  const date_info = new Date(utc_value * 1000);
  
  return moment(date_info).format('YYYY-MM-DD');
}

// Fonction pour convertir une date Excel en format YYYY-MM-DD
function convertExcelDate(value) {
  if (!value) return null;

  // Si c'est un numéro de série Excel
  if (typeof value === 'number') {
    return excelSerialDateToJSDate(value);
  }

  // Si c'est une chaîne de caractères
  if (typeof value === 'string') {
    return convertToPostgresDate(value);
  }

  // Si c'est déjà un objet Date
  if (value instanceof Date) {
    return moment(value).format('YYYY-MM-DD');
  }

  return null;
}

// Fonction pour convertir une valeur en nombre valide
function convertToNumber(value) {
  if (value === null || value === undefined || value === '') {
    return null;
  }
  
  // Si c'est déjà un nombre
  if (typeof value === 'number') {
    return isNaN(value) ? null : value;
  }
  
  // Si c'est une chaîne, nettoyer et convertir
  if (typeof value === 'string') {
    // Enlever tous les caractères non numériques sauf point et tiret
    const cleaned = value.replace(/[^\d.-]/g, '');
    const numValue = parseFloat(cleaned);
    return isNaN(numValue) ? null : numValue;
  }
  
  return null;
}


// Variable pour stocker le mapping dynamique des colonnes Excel



// Variable pour stocker le mapping dynamique des colonnes Excel


// Mapping des noms de colonnes
const excelToDbMapping = {
  'Supplier_ID': 'supplier_id',
  'PROCUREMENT ORGA': 'procurement_orga',
  'PARTNERS': 'partners',
  'Evaluated / Not Evaluated': 'evaluated_not_evaluated',
  'Calcul méthode ADEME': 'calcul_méthode_ademe',
  'Annual spend k€ A-2023': 'annual_spend_k_a_2023',
  'Santé financière': 'santé_financière',
  'Risques compliance': 'risques_compliance',
  'Vision gloable': 'vision_gloable',
  'Adresse fournisseur': 'adresse_fournisseur',
  'Analyse des risques Loi Sapin II': 'analyse_des_risques_loi_sapin_ii',
  'Région d\'intervention': 'région_d_intervention',
  'Pays d\'intervention': 'pays_d_intervention',
  'Nature du tiers': 'nature_du_tiers',
  'Ecovadis name': 'ecovadis_name',
  'Score Ecovadis': 'ecovadis_score',
  'Date': 'date',
  'Ecovadis ID': 'ecovadis_id',
  'ORGANIZATION 1': 'organization_1',
  'ORGANIZATION 2': 'organization_2',
  'ORGANIZATION COUNTRY': 'organization_country',
  'SUBSIDIARY': 'subsidiary',
  'ORIGINAL NAME PARTNER': 'original_name_partner',
  'Country of Supplier Contact': 'country_of_supplier_contact',
  'VAT number': 'vat_number',
  'Activity Area': 'activity_area',
  'Annual spend k€ A-2023': 'annual_spend_k_euros_a_2023',
  'Supplier Contact First Name': 'supplier_contact_first_name',
  'Supplier Contact Last Name': 'supplier_contact_last_name',
  'Supplier Contact Email': 'supplier_contact_email',
  'Supplier Contact Phone': 'supplier_contact_phone',
  'Adresse': 'adresse',  // Changé de 'Adresse fournisseur' à 'Adresse'
  'Nature du tiers': 'nature_tiers',
  'localisation': 'localisation',
  'Pays d\'intervention': 'pays_intervention',
  'Région d\'intervention': 'region_intervention',
  'score': 'score'
};

// Colonnes requises et optionnelles
const requiredColumns = [
  'Supplier_ID',
  'PROCUREMENT ORGA',
  'PARTNERS',
  'ORGANIZATION 1',
  'ORGANIZATION 2',
  'ORGANIZATION COUNTRY'
];

// GET all suppliers
router.get('/', async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query('SELECT * FROM fournisseurs ORDER BY id');
    
    // Créer le mapping inverse pour renvoyer les bons noms de colonnes
    const dbToExcelMapping = Object.entries(excelToDbMapping).reduce((acc, [excelName, dbName]) => {
      acc[dbName] = excelName;
      return acc;
    }, {});

    // Transformer les données pour utiliser les noms de colonnes Excel
    const transformedData = result.rows.map(row => {
      const transformedRow = {};
      for (const [dbKey, value] of Object.entries(row)) {
        const excelKey = dbToExcelMapping[dbKey] || dbKey;
        transformedRow[excelKey] = value;
      }
      return transformedRow;
    });

    res.json(transformedData);
  } catch (error) {
    console.error('Error fetching suppliers:', error);
    res.status(500).json({ error: 'Error fetching suppliers' });
  } finally {
    client.release();
  }
});

// GET test route
router.get('/test', (req, res) => {
  res.json({ message: 'API is working!' });
});

// Upload des données Excel


router.post('/upload', async (req, res) => {
  try {
    console.log('Upload request received');
    console.log('Request body:', req.body);
    console.log('Request files:', req.files ? Object.keys(req.files) : 'No files');
    
    if (!req.files || !req.files.file) {
      return res.status(400).json({ error: 'Aucun fichier n\'a été uploadé' });
    }
    
    // Vérifier que le fichier est un fichier Excel
    const file = req.files.file;
    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
      return res.status(400).json({ error: 'Le fichier doit être un fichier Excel (.xlsx ou .xls)' });
    }
    
    // Créer le nom de la table à partir du nom du fichier
    let tableName = 'fournisseurs_' + req.body.tableName;
    tableName = tableName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
    console.log(`Nom de la table: ${tableName}`);
    
    // Lire le fichier Excel
    console.log(`Lecture du fichier Excel: ${file.name}`);
    const workbook = XLSX.read(file.data);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    
    // Lire toutes les données du fichier Excel
    const data = XLSX.utils.sheet_to_json(worksheet, { 
      raw: true, 
      defval: null,
      blankrows: false
    });
    
    console.log(`Nombre de lignes lues dans le fichier Excel: ${data.length}`);
    
    if (data.length === 0) {
      return res.status(400).json({ error: 'Le fichier Excel est vide' });
    }
    
    // Extraire les noms de colonnes à partir de la première ligne
    const columns = Object.keys(data[0]);
    console.log(`Colonnes trouvées dans le fichier Excel: ${columns.join(', ')}`);
    
    // Connexion à la base de données
    const client = await pool.connect();
    
    try {
      // Supprimer la table si elle existe déjà
      await client.query(`DROP TABLE IF EXISTS "${tableName}" CASCADE`);
      console.log(`Table ${tableName} supprimée si elle existait`);
      
      // Créer la table avec toutes les colonnes du fichier Excel
      let createTableSQL = `CREATE TABLE "${tableName}" (
        id SERIAL PRIMARY KEY,
      `;
      
      // Ajouter chaque colonne avec le type TEXT
      const columnDefinitions = columns.map(col => {
        // Normaliser le nom de la colonne pour PostgreSQL
        const pgCol = col.toLowerCase()
          .replace(/[^a-zA-Z0-9àáâäãåąčćęèéêëėįìíîïłńòóôöõøùúûüųūÿýżźñçšžÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆŠŽ]+/g, '_')
          .replace(/^_|_$/g, '')
          .replace(/__+/g, '_');
        
        return `"${pgCol}" TEXT`;
      });
      
      createTableSQL += columnDefinitions.join(',\n        ');
      createTableSQL += '\n      )';
      
      await client.query(createTableSQL);
      console.log(`Table ${tableName} créée avec ${columns.length} colonnes`);
      
      // Insérer les données ligne par ligne
      let insertedCount = 0;
      let errorCount = 0;
      
      // Utiliser une transaction pour l'insertion
      await client.query('BEGIN');
      
      for (const [index, row] of data.entries()) {
        try {
          // Préparer les colonnes et les valeurs pour l'insertion
          const insertColumns = [];
          const insertValues = [];
          const placeholders = [];
          
          // Pour chaque colonne dans le fichier Excel
          columns.forEach((col, i) => {
            // Normaliser le nom de la colonne pour PostgreSQL
            const pgCol = col.toLowerCase()
              .replace(/[^a-zA-Z0-9àáâäãåąčćęèéêëėįìíîïłńòóôöõøùúûüųūÿýżźñçšžÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆŠŽ]+/g, '_')
              .replace(/^_|_$/g, '')
              .replace(/__+/g, '_');
            
            // Ajouter la colonne et la valeur
            insertColumns.push(pgCol);
            insertValues.push(row[col]);
            placeholders.push(`${i + 1}`);
          });
          
          // Construire la requête d'insertion
          const insertQuery = `
            INSERT INTO "${tableName}" (${insertColumns.map(col => `"${col}"`).join(', ')})
            VALUES (${placeholders.join(', ')})
          `;
          
          // Exécuter la requête d'insertion
          await client.query(insertQuery, insertValues);
          insertedCount++;
          
          // Afficher la progression
          if (insertedCount % 100 === 0 || insertedCount === data.length) {
            console.log(`Progression: ${insertedCount}/${data.length} lignes insérées (${Math.round(insertedCount / data.length * 100)}%)`);
          }
        } catch (error) {
          console.error(`Erreur lors de l'insertion de la ligne ${index + 1}:`, error);
          errorCount++;
        }
      }
      
      // Valider la transaction
      await client.query('COMMIT');
      
      // Vérifier le nombre final de lignes
      const countResult = await client.query(`SELECT COUNT(*) FROM "${tableName}"`);
      const finalCount = parseInt(countResult.rows[0].count);
      
      console.log(`Importation terminée:
      - Lignes dans le fichier Excel: ${data.length}
      - Lignes insérées avec succès: ${insertedCount}
      - Lignes avec erreurs: ${errorCount}
      - Nombre final de lignes dans la table: ${finalCount}
      `);
      
      // Retourner une réponse de succès
      return res.status(200).json({
        message: `Importation réussie dans la table ${tableName}`,
        table: tableName,
        stats: {
          totalRows: data.length,
          insertedRows: insertedCount,
          errorCount: errorCount,
          finalTableRows: finalCount,
          matchesExcelRowCount: finalCount === data.length
        }
      });
    } catch (error) {
      // Annuler la transaction en cas d'erreur
      await client.query('ROLLBACK');
      console.error('Erreur lors de l\'importation:', error);
      return res.status(500).json({
        error: 'Une erreur est survenue lors de l\'importation',
        details: error.message
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Erreur globale lors de l\'upload:', error);
    return res.status(500).json({
      error: 'Une erreur est survenue lors du traitement du fichier',
      details: error.message
    });
  }
});

    }
    
    // Vérifier que le fichier est un fichier Excel
    const file = req.files.file;
    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
      return res.status(400).json({ error: 'Le fichier doit être un fichier Excel (.xlsx ou .xls)' });
    }
    
    // Créer le nom de la table à partir du nom du fichier
    let tableName = 'fournisseurs_' + req.body.tableName;
    tableName = tableName.toLowerCase().replace(/[^a-z0-9_]/g, '_');
    console.log(`Nom de la table: ${tableName}`);
    
    // Lire le fichier Excel
    console.log(`Lecture du fichier Excel: ${file.name}`);
    const workbook = XLSX.read(file.data);
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    
    // Lire toutes les données du fichier Excel
    const data = XLSX.utils.sheet_to_json(worksheet, { 
      raw: true, 
      defval: null,
      blankrows: false
    });
    
    console.log(`Nombre de lignes lues dans le fichier Excel: ${data.length}`);
    
    if (data.length === 0) {
      return res.status(400).json({ error: 'Le fichier Excel est vide' });
    }
    
    // Extraire les noms de colonnes à partir de la première ligne
    const columns = Object.keys(data[0]);
    console.log(`Colonnes trouvées dans le fichier Excel: ${columns.join(', ')}`);
    
    // Connexion à la base de données
    const client = await pool.connect();
    
    try {
      // Supprimer la table si elle existe déjà
      await client.query(`DROP TABLE IF EXISTS "${tableName}" CASCADE`);
      console.log(`Table ${tableName} supprimée si elle existait`);
      
      // Créer la table avec toutes les colonnes du fichier Excel
      let createTableSQL = `CREATE TABLE "${tableName}" (
        id SERIAL PRIMARY KEY,
      `;
      
      // Ajouter chaque colonne avec le type TEXT
      const columnDefinitions = columns.map(col => {
        // Normaliser le nom de la colonne pour PostgreSQL
        const pgCol = col.toLowerCase()
          .replace(/[^a-zA-Z0-9àáâäãåąčćęèéêëėįìíîïłńòóôöõøùúûüųūÿýżźñçšžÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆŠŽ]+/g, '_')
          .replace(/^_|_$/g, '')
          .replace(/__+/g, '_');
        
        return `"${pgCol}" TEXT`;
      });
      
      createTableSQL += columnDefinitions.join(',\n        ');
      createTableSQL += '\n      )';
      
      await client.query(createTableSQL);
      console.log(`Table ${tableName} créée avec ${columns.length} colonnes`);
      
      // Insérer les données ligne par ligne
      let insertedCount = 0;
      let errorCount = 0;
      
      // Utiliser une transaction pour l'insertion
      await client.query('BEGIN');
      
      for (const [index, row] of data.entries()) {
        try {
          // Préparer les colonnes et les valeurs pour l'insertion
          const insertColumns = [];
          const insertValues = [];
          const placeholders = [];
          
          // Pour chaque colonne dans le fichier Excel
          columns.forEach((col, i) => {
            // Normaliser le nom de la colonne pour PostgreSQL
            const pgCol = col.toLowerCase()
              .replace(/[^a-zA-Z0-9àáâäãåąčćęèéêëėįìíîïłńòóôöõøùúûüųūÿýżźñçšžÀÁÂÄÃÅĄĆČĖĘÈÉÊËÌÍÎÏĮŁŃÒÓÔÖÕØÙÚÛÜŲŪŸÝŻŹÑßÇŒÆŠŽ]+/g, '_')
              .replace(/^_|_$/g, '')
              .replace(/__+/g, '_');
            
            // Ajouter la colonne et la valeur
            insertColumns.push(pgCol);
            insertValues.push(row[col]);
            placeholders.push(`${i + 1}`);
          });
          
          // Construire la requête d'insertion
          const insertQuery = `
            INSERT INTO "${tableName}" (${insertColumns.map(col => `"${col}"`).join(', ')})
            VALUES (${placeholders.join(', ')})
          `;
          
          // Exécuter la requête d'insertion
          await client.query(insertQuery, insertValues);
          insertedCount++;
          
          // Afficher la progression
          if (insertedCount % 100 === 0 || insertedCount === data.length) {
            console.log(`Progression: ${insertedCount}/${data.length} lignes insérées (${Math.round(insertedCount / data.length * 100)}%)`);
          }
        } catch (error) {
          console.error(`Erreur lors de l'insertion de la ligne ${index + 1}:`, error);
          errorCount++;
        }
      }
      
      // Valider la transaction
      await client.query('COMMIT');
      
      // Vérifier le nombre final de lignes
      const countResult = await client.query(`SELECT COUNT(*) FROM "${tableName}"`);
      const finalCount = parseInt(countResult.rows[0].count);
      
      console.log(`Importation terminée:
      - Lignes dans le fichier Excel: ${data.length}
      - Lignes insérées avec succès: ${insertedCount}
      - Lignes avec erreurs: ${errorCount}
      - Nombre final de lignes dans la table: ${finalCount}
      `);
      
      // Retourner une réponse de succès
      return res.status(200).json({
        message: `Importation réussie dans la table ${tableName}`,
        table: tableName,
        stats: {
          totalRows: data.length,
          insertedRows: insertedCount,
          errorCount: errorCount,
          finalTableRows: finalCount,
          matchesExcelRowCount: finalCount === data.length
        }
      });
    } catch (error) {
      // Annuler la transaction en cas d'erreur
      await client.query('ROLLBACK');
      console.error('Erreur lors de l\'importation:', error);
      return res.status(500).json({
        error: 'Une erreur est survenue lors de l\'importation',
        details: error.message
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Erreur globale lors de l\'upload:', error);
    return res.status(500).json({
      error: 'Une erreur est survenue lors du traitement du fichier',
      details: error.message
    });
  }
});

    }

  const file = req.files.file;
  // Vérifier si tableName est dans req.body ou utiliser le nom du fichier
  let tableName = req.body.tableName;
  
  // Si aucun nom de table n'est fourni, utiliser le nom du fichier
  if (!tableName) {
    // Extraire le nom du fichier sans l'extension
    const fileName = file.name.replace(/\.[^\.]+$/, '');
    // Convertir en format valide pour un nom de table PostgreSQL
    tableName = 'fournisseurs_' + fileName.toLowerCase()
      .replace(/[^a-z0-9]/g, '_') // Remplacer les caractères non alphanumériques par des underscores
      .replace(/_{2,}/g, '_')     // Remplacer les séquences d'underscores par un seul
      .replace(/^_|_$/g, '');     // Supprimer les underscores au début et à la fin
  }
  
  // Si le nom est trop court, utiliser le nom par défaut
  if (tableName.length < 3) {
    tableName = 'fournisseurs';
  }
  
  console.log('Table name from request body or filename:', tableName);
  
  // Vérifier que le nom de la table commence bien par "fournisseurs" pour des raisons de sécurité
  if (!tableName.startsWith('fournisseurs')) {
    return res.status(400).json({ error: 'Nom de table non autorisé' });
  }
  
  console.log(`Fichier reçu: ${file.name}, Table cible: ${tableName}`);

  // Vérifier si la table existe
  const tableCheckClient = await pool.connect();
  let tableExists = false;
  try {
    const tableCheck = await tableCheckClient.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `, [tableName]);
    
    tableExists = tableCheck.rows[0].exists;
    console.log(`Table ${tableName} existe: ${tableExists}`);
  } catch (error) {
    console.error(`Erreur lors de la vérification de la table ${tableName}:`, error);
    return res.status(500).json({ error: `Erreur lors de la vérification de la table ${tableName}` });
  } finally {
    tableCheckClient.release();
  }

  let workbook;
  try {
    workbook = XLSX.read(file.data, {
      type: 'buffer',
      raw: true,
      cellDates: true,
      dateNF: 'yyyy-mm-dd'
    });
  } catch (error) {
    console.error('Erreur lors de la lecture du fichier Excel:', error);
    return res.status(400).json({ 
      error: 'Erreur lors de la lecture du fichier Excel',
      details: error.message
    });
  }
  
  const sheetName = workbook.SheetNames[0];
  const worksheet = workbook.Sheets[sheetName];
  const data = XLSX.utils.sheet_to_json(worksheet, {
    raw: true,
    defval: null
  });
  
  // Si la table n'existe pas, la créer automatiquement en clonant la structure de la table fournisseurs
  if (!tableExists && data.length > 0) {
    console.log(`Création automatique de la table ${tableName} en clonant la structure de la table fournisseurs`);
    
    try {
      // Cloner la structure de la table fournisseurs
      const cloneSuccess = await cloneTableStructure('fournisseurs', tableName);
      
      if (!cloneSuccess) {
        console.error(`Erreur lors du clonage de la structure de la table fournisseurs vers ${tableName}`);
        return res.status(500).json({ error: `Erreur lors de la création de la table ${tableName}` });
      }
      
      console.log(`Table ${tableName} créée avec succès en clonant la structure de la table fournisseurs`);
      tableExists = true;
    } catch (error) {
      console.error(`Erreur lors de la création de la table ${tableName}:`, error);
      return res.status(500).json({ error: `Erreur lors de la création de la table ${tableName}` });
    }
  }

  console.log('Données Excel reçues:', data.length, 'lignes');
  if (data.length > 0) {
    console.log('Colonnes présentes dans le fichier:', Object.keys(data[0]).join(', '));
    console.log('Colonnes attendues:', Object.keys(excelToDbMapping).join(', '));
    
    // Fonction pour trouver une colonne de manière insensible à la casse
    const findColumn = (searchCol, availableCols) => {
      const lowerSearchCol = searchCol.toLowerCase();
      return availableCols.find(col => col.toLowerCase() === lowerSearchCol);
    };
    
    // Vérifier les colonnes requises manquantes
    const excelColumns = Object.keys(data[0]);
    console.log('Données de la première ligne:', data[0]);
    console.log('Mapping actuel:', excelToDbMapping);
    
    // Ne vérifier les colonnes requises que pour la table principale "fournisseurs"
    if (tableName === 'fournisseurs') {
      const missingRequiredColumns = requiredColumns.filter(col => {
        // Vérifier si la colonne existe exactement comme spécifiée
        if (excelColumns.includes(col)) {
          return false;
        }
        // Si non, vérifier si elle existe avec une casse différente
        const lowerCol = col.toLowerCase();
        const found = excelColumns.some(excelCol => excelCol.toLowerCase() === lowerCol);
        if (found) {
          // Trouver le nom exact de la colonne dans le fichier
          const actualColName = excelColumns.find(excelCol => excelCol.toLowerCase() === lowerCol);
          // Mettre à jour le mapping
          const dbColName = excelToDbMapping[col];
          delete excelToDbMapping[col];
          excelToDbMapping[actualColName] = dbColName;
          return false;
        }
        return true;
      });
      
      console.log('Mapping après mise à jour:', excelToDbMapping);
      
      if (missingRequiredColumns.length > 0) {
        console.error('Colonnes requises manquantes:', missingRequiredColumns);
        console.error('Colonnes présentes:', excelColumns);
        return res.status(400).json({
          error: 'Colonnes requises manquantes dans le fichier Excel',
          details: missingRequiredColumns,
          presentColumns: excelColumns,
          requiredColumns: requiredColumns
        });
      }
    } else {
      console.log(`Table ${tableName} : pas de vérification des colonnes requises`);
      
      // Pour les autres tables, mettre à jour le mapping en fonction des colonnes présentes
      Object.keys(excelToDbMapping).forEach(mappingCol => {
        const lowerMappingCol = mappingCol.toLowerCase();
        const actualColName = excelColumns.find(excelCol => 
          excelCol.toLowerCase() === lowerMappingCol
        );
        if (actualColName && actualColName !== mappingCol) {
          const dbColName = excelToDbMapping[mappingCol];
          delete excelToDbMapping[mappingCol];
          excelToDbMapping[actualColName] = dbColName;
        }
      });
    }

    // Mettre à jour le mapping pour toutes les colonnes optionnelles présentes
    Object.keys(excelToDbMapping).forEach(mappingCol => {
      if (!requiredColumns.includes(mappingCol)) {
        const lowerMappingCol = mappingCol.toLowerCase();
        const actualColName = excelColumns.find(excelCol => 
          excelCol.toLowerCase() === lowerMappingCol
        );
        if (actualColName && actualColName !== mappingCol) {
          const dbColName = excelToDbMapping[mappingCol];
          delete excelToDbMapping[mappingCol];
          excelToDbMapping[actualColName] = dbColName;
        }
      }
    });
  }

  if (data.length === 0) {
    return res.status(400).json({ error: 'Le fichier Excel est vide' });
  }

  // Compteurs pour le suivi de l'importation
  let insertedCount = 0;
  let errorCount = 0;
  let skippedCount = 0;
  let errors = [];

  // Vider la table existante si elle existe
  try {
    const truncateClient = await pool.connect();
    
    // Vérifier d'abord si la table existe
    const tableExistsQuery = `
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `;
    const tableExists = await truncateClient.query(tableExistsQuery, [tableName]);
    
    if (tableExists.rows[0].exists) {
      // Vérifier le nombre de lignes avant de vider
      const countQuery = `SELECT COUNT(*) FROM "${tableName}"`;
      const countResult = await truncateClient.query(countQuery);
      const rowCount = parseInt(countResult.rows[0].count);
      console.log(`Nombre de lignes dans la table ${tableName} avant vidage: ${rowCount}`);
      
      // Supprimer complètement la table et la recréer pour garantir qu'elle est vide
      await truncateClient.query(`DROP TABLE IF EXISTS "${tableName}" CASCADE`);
      console.log(`Table ${tableName} supprimée`);
      
      // Créer une nouvelle table avec toutes les colonnes du fichier Excel
      const { columnMapping, columnTypes } = await createDynamicTableFromExcel(truncateClient, tableName, data);
      console.log(`Table ${tableName} créée dynamiquement avec toutes les colonnes du fichier Excel`);
      
      // Mettre à jour le mapping global pour l'utiliser lors de l'insertion
      excelToDbMappingDynamic = columnMapping;
      
      // Vérifier que la table est bien vide
      const verifyEmptyQuery = `SELECT COUNT(*) FROM "${tableName}"`;
      const verifyResult = await truncateClient.query(verifyEmptyQuery);
      const emptyCount = parseInt(verifyResult.rows[0].count);
      
      if (emptyCount === 0) {
        console.log(`Table ${tableName} vidée avec succès (vérification: ${emptyCount} lignes)`);
      } else {
        console.error(`ERREUR: La table ${tableName} n'a pas été correctement vidée! (${emptyCount} lignes restantes)`);
        return res.status(500).json({ error: `Erreur lors du vidage de la table. Veuillez réessayer.` });
      }
    } else {
      console.log(`La table ${tableName} n'existe pas encore, création de la table`);
      
      // Créer une nouvelle table avec toutes les colonnes du fichier Excel
      const { columnMapping, columnTypes } = await createDynamicTableFromExcel(truncateClient, tableName, data);
      console.log(`Table ${tableName} créée dynamiquement avec toutes les colonnes du fichier Excel`);
      
      // Mettre à jour le mapping global pour l'utiliser lors de l'insertion
      excelToDbMappingDynamic = columnMapping;
    }
    
    // Créer un verrou d'importation pour éviter les importations multiples
    const lockTableName = `${tableName}_lock`;
    const createLockTableQuery = `
      CREATE TABLE IF NOT EXISTS "${lockTableName}" (
        id SERIAL PRIMARY KEY,
        start_time TIMESTAMP DEFAULT NOW(),
        file_name TEXT,
        row_count INTEGER,
        status TEXT DEFAULT 'in_progress'
      )
    `;
    await truncateClient.query(createLockTableQuery);
    
    // Vérifier s'il y a une importation en cours
    const checkLockQuery = `
      SELECT * FROM "${lockTableName}"
      WHERE status = 'in_progress'
      ORDER BY start_time DESC
      LIMIT 1
    `;
    const lockResult = await truncateClient.query(checkLockQuery);
    
    if (lockResult.rows.length > 0) {
      const lock = lockResult.rows[0];
      const lockTime = new Date(lock.start_time).toLocaleString();
      console.error(`ERREUR: Une importation est déjà en cours depuis ${lockTime}`);
      return res.status(409).json({ 
        error: `Une importation est déjà en cours depuis ${lockTime}. Veuillez attendre qu'elle se termine ou annulez-la.` 
      });
    }
    
    // Créer un verrou pour cette importation
    const createLockQuery = `
      INSERT INTO "${lockTableName}" (file_name, row_count)
      VALUES ($1, $2)
      RETURNING id
    `;
    const lockInsertResult = await truncateClient.query(createLockQuery, [req.files.file.name, data.length]);
    const lockId = lockInsertResult.rows[0].id;
    console.log(`Verrou d'importation créé avec l'ID ${lockId}`);
    
    truncateClient.release();
  } catch (error) {
    console.error(`Erreur lors du vidage de la table ${tableName}:`, error);
    return res.status(500).json({ error: `Erreur lors du vidage de la table: ${error.message}` });
  }

  // Utiliser les compteurs déjà définis
  
  // Utiliser une transaction pour toute l'importation
  const globalClient = await pool.connect();
  try {
    await globalClient.query('BEGIN');
    
    console.log(`Début de l'importation de ${data.length} lignes...`);
    let successCount = 0;
    let errorCount = 0;
    let skipCount = 0;
    let insertedCount = 0; // Pour compatibilité avec le code existant
    
    // Préparer et insérer les données ligne par ligne
    for (const [index, row] of data.entries()) {
      // Utiliser le client global pour toutes les opérations
      const insertClient = globalClient;
      let mappedRow = {};
    
    try {
      mappedRow = {};
      
      // Utiliser le mapping prédéfini pour toutes les tables
      // Créer un mapping des colonnes Excel vers les colonnes de la base de données
      const columnsToProcess = [];
      
      // Récupérer la liste des colonnes disponibles dans la table
      const tableColumnsQuery = `
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = $1
      `;
      
      const tableColumnsResult = await insertClient.query(tableColumnsQuery, [tableName]);
      const availableColumns = tableColumnsResult.rows.map(row => row.column_name);
      console.log(`Colonnes disponibles dans la table ${tableName}:`, availableColumns);
      
      // Pour chaque colonne Excel, utiliser le mapping dynamique créé lors de la création de la table
      Object.keys(row).forEach(excelCol => {
        // D'abord, essayer de trouver via le mapping dynamique
        let dbCol = excelToDbMappingDynamic[excelCol];
        
        // Si pas dans le mapping dynamique, essayer le mapping prédéfini
        if (!dbCol) {
          dbCol = excelToDbMapping[excelCol];
        }
        
        // Si toujours pas trouvé, convertir en snake_case
        if (!dbCol) {
          if (excelCol === 'Evaluated / Not Evaluated') {
            dbCol = 'evaluated_not_evaluated';
          } else {
            dbCol = excelCol.toLowerCase().replace(/[^a-z0-9]+/g, '_').replace(/^_|_$/g, '');
          }
        }
        
        // Vérifier si la colonne existe dans la table
        if (availableColumns.includes(dbCol)) {
          columnsToProcess.push({ excelCol, dbCol });
        } else {
          console.log(`Colonne ${dbCol} non trouvée dans la table ${tableName}, ignorée`);
        }
      });
      
      // Traiter chaque colonne
      columnsToProcess.forEach(({ excelCol, dbCol }) => {
        // Si la colonne de destination a déjà une valeur non-null, ne pas l'écraser
        if (mappedRow[dbCol] !== undefined && mappedRow[dbCol] !== null) {
          console.log(`Ligne ${index + 1}: Valeur déjà définie pour ${dbCol}:`, mappedRow[dbCol]);
          return;
        }
        
        let value = row[excelCol];
        
        // Nettoyage des chaînes
        if (typeof value === 'string') {
          value = value.trim();
          if (value === '') {
            value = null;
          }
        }
        
        // Générer un ID temporaire pour les lignes sans supplier_id
        if (dbCol === 'supplier_id' && (value === null || value === undefined)) {
          value = `TEMP_${index + 1}`;
          console.log(`Ligne ${index + 1}: Génération d'un ID temporaire: ${value}`);
        }
        
        // Conversion des dates
        if ((dbCol === 'date' || dbCol.toLowerCase().includes('date')) && value !== null && value !== undefined) {
          const originalValue = value;
          
          // Si c'est déjà un objet Date
          if (value instanceof Date) {
            value = moment(value).format('YYYY-MM-DD');
          } else if (typeof value === 'number') {
            value = convertExcelDate(value);
          } else if (typeof value === 'string') {
            // Essayer de convertir une date au format texte
            const dateValue = convertToPostgresDate(value);
            if (dateValue) {
              value = dateValue;
            }
          }
          
          if (!value) {
            console.warn(`Ligne ${index + 1}: Date invalide "${originalValue}" (type: ${typeof originalValue})`);
            value = null;
          }
        }
        
        // Conversion des nombres pour les colonnes spécifiques
        if (dbCol.includes('annual_spend') || dbCol.includes('amount') || dbCol.includes('price') || 
            dbCol.includes('cost') || dbCol.includes('value')) {
          const originalValue = value;
          value = convertToNumber(value);
        }
        
        // Conversion du score en entier
        if (dbCol === 'score') {
          const originalValue = value;
          const numValue = convertToNumber(value);
          value = numValue !== null ? Math.round(numValue) : null;
        }
        
        // Cas spécial pour evaluated_not_evaluated - toujours traiter comme du texte
        if (dbCol === 'evaluated_not_evaluated') {
          if (value !== null && value !== undefined && typeof value !== 'string') {
            value = String(value);
          }
        }
        
        // Pour les colonnes qui semblent être des entiers
        if (dbCol.includes('id') || dbCol.endsWith('_id') || dbCol.startsWith('id_')) {
          // Si c'est une chaîne qui n'est pas un nombre, la laisser telle quelle
          if (typeof value === 'string' && !/^-?\d+$/.test(value)) {
            // Ne rien faire, garder la chaîne telle quelle
          } else if (value !== null && value !== undefined) {
            // Essayer de convertir en entier
            const numValue = convertToNumber(value);
            if (numValue !== null) {
              value = Math.round(numValue);
            }
          }
        }
        
        mappedRow[dbCol] = value;
      });
      
      // Si la table est vide, ajouter une valeur par défaut pour id
      if (Object.keys(mappedRow).length === 0) {
        console.warn(`Ligne ${index + 1}: Aucune colonne valide trouvée pour la table ${tableName}`);
        mappedRow = { id: null }; // Sera remplacé par la séquence auto-incrémentée
      }

      // Ne jamais ignorer l'insertion pour garantir le même nombre de lignes
      let skipInsertion = false;
      
      if (!skipInsertion) {
        const columns = Object.keys(mappedRow);
        const values = Object.values(mappedRow);
        const placeholders = values.map((_, i) => `$${i + 1}`).join(', ');
        
        const insertQuery = `
          INSERT INTO "${tableName}" (${columns.join(', ')})
          VALUES (${placeholders})
          RETURNING id
        `;
        
        try {
          console.log(`Exécution de la requête d'insertion pour la ligne ${index + 1}:`);
          console.log(`Colonnes: ${columns.join(', ')}`);
          console.log(`Valeurs: ${values.map(v => typeof v === 'object' ? JSON.stringify(v) : v).join(', ')}`);
          
          const result = await insertClient.query(insertQuery, values);
          console.log(`Ligne ${index + 1}: Insertion réussie avec l'ID ${result.rows[0].id}`);
          insertedCount++;
          successCount++;
        } catch (error) {
          console.error(`Ligne ${index + 1}: Erreur lors de l'insertion:`, error);
          errorCount++;
          // Continuer malgré l'erreur pour les autres lignes
        }
      } else {
        skippedCount++;
        insertedCount++;
      }

    } catch (error) {
      await insertClient.query('ROLLBACK');
      console.error(`Erreur d'insertion à la ligne ${index + 1}:`, error);
      console.error('Données de la ligne:', JSON.stringify(mappedRow, null, 2));
      console.error('Détails de l\'erreur:', {
        message: error.message,
        code: error.code,
        detail: error.detail,
        hint: error.hint,
        position: error.position
      });
      
      errors.push({
        line: index + 1,
        error: error.message,
        code: error.code,
        detail: error.detail,
        data: mappedRow
      });
      errorCount++;
    }
      
      // Afficher la progression toutes les 100 lignes
      if ((index + 1) % 100 === 0 || index === data.length - 1) {
        console.log(`Progression: ${index + 1}/${data.length} lignes traitées (${Math.round((index + 1) / data.length * 100)}%)`);
      }
    }
    
    // Valider la transaction
    await globalClient.query('COMMIT');
    console.log(`Importation terminée: ${successCount} succès, ${errorCount} erreurs, ${skipCount} ignorées`);
  } catch (error) {
    // Annuler la transaction en cas d'erreur
    await globalClient.query('ROLLBACK');
    console.error(`Erreur globale lors de l'importation: ${error.message}`);
    throw error;
  } finally {
    globalClient.release();
  }

  // Envoyer la réponse finale
  if (errorCount === data.length) {
    return res.status(500).json({
      error: 'Toutes les lignes ont échoué à l\'import',
      details: errors
    });
  }

  // Vérifier le nombre final de lignes dans la table
  try {
    const verifyClient = await pool.connect();
    const countQuery = `SELECT COUNT(*) FROM "${tableName}"`;
    const countResult = await verifyClient.query(countQuery);
    const finalRowCount = parseInt(countResult.rows[0].count);
    
    // Compter les lignes par type
    const supplierIdQuery = `SELECT 
      COUNT(*) as total,
      COUNT(CASE WHEN supplier_id IS NOT NULL THEN 1 END) as with_supplier_id,
      COUNT(CASE WHEN supplier_id IS NULL THEN 1 END) as without_supplier_id,
      COUNT(CASE WHEN supplier_id LIKE 'TEMP_%' THEN 1 END) as with_temp_id
    FROM "${tableName}"`;
    
    const supplierIdResult = await verifyClient.query(supplierIdQuery);
    const stats = supplierIdResult.rows[0];
    
    console.log(`Statistiques détaillées:
    - Total: ${stats.total}
    - Avec supplier_id: ${stats.with_supplier_id}
    - Sans supplier_id: ${stats.without_supplier_id}
    - Avec ID temporaire: ${stats.with_temp_id}
    `);
    
    console.log(`Résumé de l'importation:`);
    console.log(`- Lignes dans le fichier Excel: ${data.length}`);
    console.log(`- Lignes insérées avec succès: ${insertedCount}`);
    console.log(`- Lignes avec erreurs: ${errorCount}`);
    console.log(`- Lignes ignorées: ${skippedCount}`);
    console.log(`- Nombre final de lignes dans la table: ${finalRowCount}`);
    
    // Mettre à jour le statut du verrou d'importation
    const lockTableName = `${tableName}_lock`;
    const updateLockQuery = `
      UPDATE "${lockTableName}"
      SET status = $1
      WHERE status = 'in_progress'
      ORDER BY start_time DESC
      LIMIT 1
    `;
    
    if (finalRowCount !== data.length) {
      console.warn(`ATTENTION: Le nombre de lignes dans la table (${finalRowCount}) ne correspond pas au nombre de lignes dans le fichier Excel (${data.length})!`);
      await verifyClient.query(updateLockQuery, ['warning']);
    } else {
      console.log(`SUCCÈS: Le nombre de lignes dans la table correspond exactement au nombre de lignes dans le fichier Excel.`);
      await verifyClient.query(updateLockQuery, ['completed']);
    }
    
    verifyClient.release();
    
    // Retourner une réponse de succès
    return res.status(200).json({
      message: `Importation réussie dans la table ${tableName}`,
      table: tableName,
      stats: {
        totalRows: data.length,
        insertedRows: insertedCount,
        errorCount: errorCount,
        errors: errors,
        finalTableRows: finalRowCount,
        matchesExcelRowCount: finalRowCount === data.length
      }
    });
  } catch (error) {
    console.error(`Erreur lors de la vérification finale:`, error);
    
    // Mettre à jour le statut du verrou d'importation en cas d'erreur
    try {
      const errorClient = await pool.connect();
      const lockTableName = `${tableName}_lock`;
      const updateLockQuery = `
        UPDATE "${lockTableName}"
        SET status = 'error'
        WHERE status = 'in_progress'
        ORDER BY start_time DESC
        LIMIT 1
      `;
      await errorClient.query(updateLockQuery);
      errorClient.release();
    } catch (lockError) {
      console.error(`Erreur lors de la mise à jour du verrou:`, lockError);
    }
    
    // Retourner une réponse de succès même en cas d'erreur de vérification
    return res.status(200).json({
      message: `Importation terminée dans la table ${tableName}, mais erreur lors de la vérification finale`,
      table: tableName,
      stats: {
        totalRows: data.length,
        insertedRows: insertedCount,
        errorCount: errorCount,
        errors: errors
      }
    });
  }
  } catch (error) {
    console.error('Erreur globale lors de l\'upload:', error);
    res.status(500).json({
      error: 'Une erreur est survenue lors du traitement du fichier',
      details: error.message
    });
  }
});

// Route pour récupérer les données d'une table spécifique
router.get('/table/:tableName', async (req, res) => {
  const { tableName } = req.params;
  
  // Vérifier que le nom de la table commence bien par "fournisseurs" pour des raisons de sécurité
  if (!tableName.startsWith('fournisseurs')) {
    return res.status(400).json({ error: 'Nom de table non autorisé' });
  }
  
  const client = await pool.connect();
  try {
    // Vérifier que la table existe
    const tableCheck = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `, [tableName]);
    
    if (!tableCheck.rows[0].exists) {
      return res.status(404).json({ error: `La table ${tableName} n'existe pas` });
    }
    
    // Récupérer les données de la table
    const result = await client.query(`SELECT * FROM "${tableName}"`);
    res.json(result.rows);
  } catch (error) {
    console.error(`Erreur lors de la récupération des données de la table ${tableName}:`, error);
    res.status(500).json({ error: `Erreur lors de la récupération des données de la table ${tableName}` });
  } finally {
    client.release();
  }
});

// Route pour récupérer toutes les tables commençant par "fournisseurs"
router.get('/tables', async (req, res) => {
  const client = await pool.connect();
  try {
    const result = await client.query(`
      SELECT tablename
      FROM pg_catalog.pg_tables
      WHERE schemaname = 'public'
      AND tablename != 'groups'
      ORDER BY tablename
    `);
    
    const tables = result.rows.map(row => row.tablename);
    res.json({ tables });
  } catch (error) {
    console.error('Erreur lors de la récupération des tables:', error);
    res.status(500).json({ error: 'Erreur lors de la récupération des tables' });
  } finally {
    client.release();
  }
});

// Récupérer les données d'une table spécifique
router.get('/table/:tableName', async (req, res) => {
  const { tableName } = req.params;
  const client = await pool.connect();
  
  try {
    // Vérifier si la table existe
    const tableCheck = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `, [tableName]);
    
    if (!tableCheck.rows[0].exists) {
      return res.status(404).json({ error: `La table ${tableName} n'existe pas` });
    }
    
    // Récupérer les données de la table
    const result = await client.query(`SELECT * FROM "${tableName}" LIMIT 5000`);
    
    res.json(result.rows);
  } catch (error) {
    console.error(`Erreur lors de la récupération des données de la table ${tableName}:`, error);
    res.status(500).json({ error: `Erreur lors de la récupération des données de la table ${tableName}` });
  } finally {
    client.release();
  }
});

// Route pour vider une table spécifique
router.post('/truncate/:tableName', async (req, res) => {
  const { tableName } = req.params;
  
  // Vérifier que le nom de la table commence bien par "fournisseurs" pour des raisons de sécurité
  if (!tableName.startsWith('fournisseurs')) {
    return res.status(400).json({ error: 'Nom de table non autorisé' });
  }
  
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // Vérifier que la table existe
    const tableCheck = await client.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = $1
      )
    `, [tableName]);
    
    if (!tableCheck.rows[0].exists) {
      throw new Error(`La table ${tableName} n'existe pas`);
    }
    
    // Vider la table
    await client.query(`TRUNCATE TABLE "${tableName}" RESTART IDENTITY`);
    await client.query('COMMIT');
    
    res.json({ success: true, message: `Table ${tableName} vidée avec succès` });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error(`Erreur lors de la suppression des données de la table ${tableName}:`, error);
    res.status(500).json({ 
      error: `Erreur lors de la suppression des données de la table ${tableName}`,
      details: error.message
    });
  } finally {
    client.release();
  }
});

// Route pour vider la table fournisseurs
router.post('/truncate', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    await client.query('TRUNCATE TABLE fournisseurs RESTART IDENTITY');
    await client.query('COMMIT');
    res.json({ message: 'Table vidée avec succès' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Erreur lors de la suppression des données:', error);
    res.status(500).json({ error: 'Erreur lors de la suppression des données' });
  } finally {
    client.release();
  }
});

// Route pour vider la table fournisseurs
router.delete('/clear', async (req, res) => {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    
    // Vider la table fournisseurs
    await client.query('TRUNCATE TABLE fournisseurs RESTART IDENTITY CASCADE');
    
    await client.query('COMMIT');
    res.json({ message: 'Tables vidées avec succès' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Erreur détaillée lors du vidage des tables:', error);
    res.status(500).json({ 
      error: 'Erreur lors du vidage des tables',
      details: error.message,
      stack: error.stack 
    });
  } finally {
    client.release();
  }
});

// Créer un groupe et importer des données
router.post('/createGroup', async (req, res) => {
  const { groupName, data, columns } = req.body;
  const client = await pool.connect();

  try {
    await client.query('BEGIN');

    // Créer la table avec les colonnes visibles
    const createTableQuery = `
      CREATE TABLE "${groupName}" (
        ${columns.map(col => `"${col}" TEXT`).join(', ')}
      )
    `;
    await client.query(createTableQuery);

    // Insérer les données filtrées
    if (data.length > 0) {
      // Préparer la requête d'insertion par lots de 1000 lignes
      const batchSize = 1000;
      for (let i = 0; i < data.length; i += batchSize) {
        const batch = data.slice(i, i + batchSize);
        
        const values = [];
        const placeholders = [];
        let paramCounter = 1;

        batch.forEach((row) => {
          const rowValues = columns.map(col => row[col] || null);
          values.push(...rowValues);
          const rowPlaceholders = columns.map(() => `$${paramCounter++}`);
          placeholders.push(`(${rowPlaceholders.join(', ')})`);
        });

        const insertQuery = `
          INSERT INTO "${groupName}" (${columns.map(col => `"${col}"`).join(', ')})
          VALUES ${placeholders.join(', ')}
        `;

        await client.query(insertQuery, values);
      }
    }

    await client.query('COMMIT');
    res.json({ success: true, message: 'Groupe créé avec succès' });
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Erreur lors de la création du groupe:', error);
    res.status(500).json({ 
      success: false, 
      message: error.code === '42P07' ? 'Un groupe avec ce nom existe déjà' : 'Erreur lors de la création du groupe',
      details: error.message
    });
  } finally {
    client.release();
  }
});

// Récupérer la liste des groupes
router.get('/groups', async (req, res) => {
  const client = await pool.connect();
  try {
    // D'abord, récupérer la liste des tables
    const tablesResult = await client.query(`
      SELECT table_name
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_name != 'fournisseurs'
      AND table_type = 'BASE TABLE'
      AND table_name NOT IN ('pg_stat_statements', 'pg_stat_statements_info')
    `);

    // Ensuite, pour chaque table, récupérer le nombre d'enregistrements
    const groups = [];
    for (const row of tablesResult.rows) {
      try {
        const countResult = await client.query(`
          SELECT COUNT(*) as count 
          FROM "${row.table_name}"
        `);
        
        groups.push({
          name: row.table_name,
          record_count: parseInt(countResult.rows[0].count),
          created_at: new Date().toISOString() // Pour l'instant, on utilise la date actuelle
        });
      } catch (err) {
        console.error(`Erreur lors du comptage pour la table ${row.table_name}:`, err);
        // On continue avec la table suivante
      }
    }
    
    res.json(groups);
  } catch (error) {
    console.error('Erreur lors de la récupération des groupes:', error);
    res.status(500).json({ 
      error: 'Erreur lors de la récupération des groupes',
      details: error.message 
    });
  } finally {
    client.release();
  }
});

// Récupérer les données d'un groupe spécifique
router.get('/groups/:name', async (req, res) => {
  const { name } = req.params;
  const client = await pool.connect();
  try {
    const result = await client.query(`SELECT * FROM "${name}"`);
    res.json({
      data: result.rows,
      metadata: {
        visibleColumns: null,  // Ces valeurs seront définies par le frontend
        filters: null         // Ces valeurs seront définies par le frontend
      }
    });
  } catch (error) {
    console.error('Erreur lors de la récupération des données du groupe:', error);
    res.status(500).json({ error: 'Erreur lors de la récupération des données du groupe' });
  } finally {
    client.release();
  }
});

// Supprimer un groupe
router.delete('/groups/:name', async (req, res) => {
  const { name } = req.params;
  const client = await pool.connect();
  try {
    await client.query(`DROP TABLE IF EXISTS "${name}"`);
    res.json({ success: true, message: 'Groupe supprimé avec succès' });
  } catch (error) {
    console.error('Erreur lors de la suppression du groupe:', error);
    res.status(500).json({ error: 'Erreur lors de la suppression du groupe' });
  } finally {
    client.release();
  }
});

// Route pour exporter un groupe en Excel
router.post('/groups/export/excel', async (req, res) => {
  const { groupName } = req.body;
  const client = await pool.connect();
  
  try {
    console.log('Début export Excel pour le groupe:', groupName);

    // Colonnes à cacher
    const hiddenColumns = [
      'details', 
      'Note Risque Financier', 
      'Note de Conformité', 
      'risque_detaille',
      'HUYI MODIFICATION',
      'PARTNERS TRADUCTION',
      'Activity Area',
      'Notation ESG',
      'Santé financière',
      'Risques compliance',
      'Calcul méthode ADEME',
      'Scope 1',
      'Scope 2',
      'Scope 3',
      'Vision gloable',
      'ORGANIZATION 3',
      'ORGANIZATION ZONE',
      'Comments',
      'Adresse fournisseur',
      'Analyse des risques Loi Sapin II'
    ];

    // Récupérer les données du groupe
    const result = await client.query(`SELECT * FROM "${groupName}"`);
    const data = result.rows;
    
    console.log('Nombre de lignes récupérées:', data.length);
    
    if (data.length === 0) {
      throw new Error('Aucune donnée à exporter');
    }

    // Créer un nouveau workbook Excel
    const workbook = XLSX.utils.book_new();
    
    // Filtrer les colonnes cachées
    const columns = Object.keys(data[0]).filter(col => !hiddenColumns.includes(col));
    console.log('Colonnes détectées (après filtrage):', columns);
    
    // Créer le worksheet avec les données filtrées
    const worksheetData = data.map(row => {
      const filteredRow = {};
      columns.forEach(col => {
        filteredRow[col] = row[col];
      });
      return filteredRow;
    });

    const worksheet = XLSX.utils.json_to_sheet(worksheetData, {
      header: columns
    });

    // Définir la largeur des colonnes
    const colWidth = 20;
    worksheet['!cols'] = columns.map(() => ({ wch: colWidth }));

    // Ajouter la feuille au workbook
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Données');

    // Générer le buffer Excel
    const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

    // Envoyer le fichier
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', `attachment; filename=${groupName}.xlsx`);
    res.send(excelBuffer);

    console.log('Export Excel terminé avec succès');
  } catch (error) {
    console.error('Erreur lors de l\'export Excel:', error);
    res.status(500).json({ 
      error: 'Erreur lors de l\'export Excel',
      details: error.message 
    });
  } finally {
    client.release();
  }
});

// Route pour exporter un groupe en CSV
router.post('/groups/export/csv', async (req, res) => {
  const { groupName } = req.body;
  const client = await pool.connect();
  
  try {
    console.log('Début export CSV pour le groupe:', groupName);

    // Colonnes à cacher
    const hiddenColumns = [
      'details', 
      'Note Risque Financier', 
      'Note de Conformité', 
      'risque_detaille',
      'HUYI MODIFICATION',
      'PARTNERS TRADUCTION',
      'Activity Area',
      'Notation ESG',
      'Santé financière',
      'Risques compliance',
      'Calcul méthode ADEME',
      'Scope 1',
      'Scope 2',
      'Scope 3',
      'Vision gloable',
      'ORGANIZATION 3',
      'ORGANIZATION ZONE',
      'Comments',
      'Adresse fournisseur',
      'Analyse des risques Loi Sapin II'
    ];

    // Récupérer les données du groupe
    const result = await client.query(`SELECT * FROM "${groupName}"`);
    const data = result.rows;
    
    console.log('Nombre de lignes récupérées:', data.length);
    
    if (data.length === 0) {
      throw new Error('Aucune donnée à exporter');
    }

    // Formater les données pour CSV en excluant les colonnes cachées
    const formattedData = data.map(row => {
      const newRow = {};
      Object.keys(row).forEach(key => {
        if (!hiddenColumns.includes(key)) {
          if (row[key] instanceof Date) {
            newRow[key] = row[key].toLocaleString('fr-FR');
          } else {
            newRow[key] = row[key];
          }
        }
      });
      return newRow;
    });

    // Options pour la conversion CSV
    const csvOptions = {
      fields: Object.keys(data[0]).filter(col => !hiddenColumns.includes(col)),
      delimiter: ';',  // Utiliser ; comme séparateur pour meilleure compatibilité avec Excel
      quote: '"',      // Utiliser les guillemets doubles pour les champs
      escapedQuote: '""', // Échapper les guillemets dans les champs
      header: true     // Inclure les en-têtes
    };

    console.log('Conversion en CSV...');
    // Convertir en CSV
    const csv = parse(formattedData, csvOptions);
    console.log('Taille du CSV:', csv.length);

    // Ajouter BOM pour Excel
    const csvWithBOM = '\ufeff' + csv;

    // Envoyer le fichier
    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename="${groupName}.csv"`);
    res.send(csvWithBOM);

    console.log('Export CSV terminé avec succès');

  } catch (error) {
    console.error('Erreur lors de l\'export CSV:', error);
    res.status(500).json({ 
      success: false, 
      message: 'Erreur lors de l\'export CSV',
      error: error.message 
    });
  } finally {
    client.release();
  }
});

// Route pour télécharger un fichier temporaire
router.get('/download/:filename', (req, res) => {
  const { filename } = req.params;
  const filePath = path.join(os.tmpdir(), filename);

  res.download(filePath, (err) => {
    if (err) {
      console.error('Erreur lors du téléchargement:', err);
    }
    // Supprimer le fichier temporaire après le téléchargement
    fs.unlink(filePath, (unlinkErr) => {
      if (unlinkErr) {
        console.error('Erreur lors de la suppression du fichier temporaire:', unlinkErr);
      }
    });
  });
});

// Route pour ouvrir un PDF localement
router.get('/open-pdf/:filename', (req, res) => {
  const filename = decodeURIComponent(req.params.filename);
  const filePath = path.join(__dirname, '../../Reports_Moodies', filename);
  console.log('Tentative d\'ouverture du fichier:', filePath);
  
  if (!fs.existsSync(filePath)) {
    console.error('Fichier non trouvé:', filePath);
    return res.status(404).json({ error: 'Fichier non trouvé' });
  }

  try {
    // Utiliser la commande système appropriée pour ouvrir le PDF
    const { exec } = require('child_process');
    exec(`start "" "${filePath}"`, (error) => {
      if (error) {
        console.error('Erreur lors de l\'ouverture du fichier:', error);
        return res.status(500).json({ error: 'Erreur lors de l\'ouverture du fichier' });
      }
      res.json({ success: true });
    });
  } catch (error) {
    console.error('Erreur lors de l\'exécution de la commande:', error);
    res.status(500).json({ error: 'Erreur lors de l\'ouverture du fichier' });
  }
});

// Route spécifique pour le PDF de PLASTUNI NORMANDIE SAS
router.get('/plastuni-pdf', (req, res) => {
  const filePath = path.resolve(__dirname, '../../Reports_Moodies/Export 21_02_2025 10_05.pdf');
  console.log('Tentative d\'accès au fichier Plastuni:', filePath);
  
  if (!fs.existsSync(filePath)) {
    console.error('Fichier Plastuni non trouvé:', filePath);
    return res.status(404).json({ error: 'Fichier non trouvé' });
  }

  res.sendFile(filePath, (err) => {
    if (err) {
      console.error('Erreur lors de l\'envoi du fichier:', err);
      res.status(500).json({ error: 'Erreur lors de l\'envoi du fichier' });
    }
  });
});

// Route spécifique pour le PDF de TUPACK VERPACKUNGEN
router.get('/tupack-pdf', (req, res) => {
  const filePath = path.resolve(__dirname, '../../Reports_Moodies/Export 21_02_2025 10_09.pdf');
  console.log('Tentative d\'accès au fichier Tupack:', filePath);
  
  if (!fs.existsSync(filePath)) {
    console.error('Fichier Tupack non trouvé:', filePath);
    return res.status(404).json({ error: 'Fichier non trouvé' });
  }

  res.sendFile(filePath, (err) => {
    if (err) {
      console.error('Erreur lors de l\'envoi du fichier:', err);
      res.status(500).json({ error: 'Erreur lors de l\'envoi du fichier' });
    }
  });
});

// Route pour uploader un fichier Moodies
router.post('/moodies-report/:id', upload.single('file'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'Aucun fichier n\'a été uploadé' });
    }

    const client = await pool.connect();
    try {
      // Mettre à jour la base de données avec le nom du fichier et le statut d'évaluation
      await client.query(
        'UPDATE fournisseurs SET moodies_report = $1, evaluated_not_evaluated = $2 WHERE id = $3',
        [req.file.filename, 'Evaluated', req.params.id]
      );

      res.json({
        success: true,
        message: 'Fichier uploadé avec succès',
        filename: req.file.filename
      });
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Erreur lors de l\'upload du fichier:', error);
    res.status(500).json({ 
      success: false,
      error: 'Erreur lors de l\'upload du fichier',
      details: error.message 
    });
  }
});

// Route pour télécharger un fichier Moodies
router.get('/moodies-report/:filename', (req, res) => {
  const filePath = path.join(__dirname, '../../Reports_Moodies', req.params.filename);
  console.log('Tentative d\'accès au fichier:', filePath);
  
  if (!fs.existsSync(filePath)) {
    console.error('Fichier non trouvé:', filePath);
    return res.status(404).json({ error: 'Fichier non trouvé' });
  }

  // Log le succès
  console.log('Fichier trouvé, envoi en cours...');

  // Définir les en-têtes pour afficher le PDF dans le navigateur
  res.setHeader('Content-Type', 'application/pdf');
  res.setHeader('Content-Disposition', 'inline; filename=' + req.params.filename);

  // Envoyer le fichier avec gestion d'erreur
  const fileStream = fs.createReadStream(filePath);

// Variable pour stocker le mapping dynamique des colonnes Excel
let excelToDbMappingDynamic = {};

  
  fileStream.on('error', (error) => {
    console.error('Erreur lors de la lecture du fichier:', error);
    res.status(500).json({ error: 'Erreur lors de la lecture du fichier' });
  });

  fileStream.pipe(res);
});

module.exports = router;
